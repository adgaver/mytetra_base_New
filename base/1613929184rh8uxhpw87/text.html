<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'MS Shell Dlg 2'; font-size:9pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a href="https://gist.github.com/Titiaiev/dcb7298389d1276b823bbc96e29f940d"><span style=" text-decoration: underline; color:#0000ff;">https://gist.github.com/Titiaiev/dcb7298389d1276b823bbc96e29f940d</span></a></p>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:xx-large; font-weight:600;">Основы BASH. Часть 1 </span></p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a href="https://habr.com/ru/hub/linux/"><span style=" text-decoration: underline; color:#0000ff;">Настройка Linux</span></a> </li></ul>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Tutorial </li></ul>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="post-content-body"></a>Безусловно, все те кто общается с ОС Linux хоть раз да имели дело(во всяком случае слышали точно) с командной оболочкой BASH. Но BASH не только командная оболочка, это еще и превосходный скриптовый язык программирования.<br />Цель этой статьи — познакомить поближе юзеров с bash, рассказать про синтаксис, основные приемы и фишки языка, для того чтобы даже обычный пользователь смог быстренько написать простой скрипт для выполнения ежедневной(-недельной, -месячной) рутинной работы или, скажем, «на коленке» наваять скриптик для бэкапа директории.<br /><a name="habracut"></a><br /></p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">Введение</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />BASH — Bourne-Again SHell (что может переводится как «перерожденный шел», или «Снова шел Борна(создатель sh)»), самый популярный командный интерпретатор в юниксоподобных системах, в особенности в GNU/Linux. Ниже приведу ряд встроенных команд, которые мы будем использовать для создания своих скриптов.<br /><br /><span style=" font-family:'Courier New';">break выход из цикла for, while или until<br />continue выполнение следующей итерации цикла for, while или until<br />echo вывод аргументов, разделенных пробелами, на стандартное устройство вывода<br />exit выход из оболочки<br />export отмечает аргументы как переменные для передачи в дочерние процессы в среде<br />hash запоминает полные имена путей команд, указанных в качестве аргументов, чтобы не искать их при следующем обращении<br />kill посылает сигнал завершения процессу<br />pwd выводит текущий рабочий каталог<br />read читает строку из ввода оболочки и использует ее для присвоения значений указанным переменным.\<br />return заставляет функцию оболочки выйти с указанным значением<br />shift перемещает позиционные параметры налево<br />test вычисляет условное выражение<br />times выводит имя пользователя и системное время, использованное оболочкой и ее потомками<br />trap указывает команды, которые должны выполняться при получении оболочкой сигнала<br />unset вызывает уничтожение переменных оболочки<br />wait ждет выхода из дочернего процесса и сообщает выходное состояние.<br /></span><br />И конечно же кроме встроенных команд мы будем использовать целую кучу внешних, отдельных команд-программ, с которыми мы познакомимся уже в процессе<br /><br /></p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">Что необходимо знать с самого начала</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />1. Любой bash-скрипт должен начинаться со строки:<br /><br /><span style=" font-family:'Courier New';">#!/bin/bash</span><br />в этой строке после #! указывается путь к bash-интерпретатору, поэтому если он у вас установлен в другом месте(где, вы можете узнать набрав whereis bash) поменяйте её на ваш путь.<br />2. Коментарии начинаются с символа # (кроме первой строки).<br />3. В bash переменные не имеют типа(о них речь пойдет ниже)<br /><br /></p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">Переменные и параметры скрипта</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Приведу как пример небольшой пример, который мы разберем:<br /><br /><span style=" font-family:'Courier New';">#!/bin/bash <br />#указываем где у нас хранится bash-интерпретатор <br />parametr1=$1 #присваиваем переменной parametr1 значение первого параметра скрипта<br />script_name=$0 #присваиваем переменной script_name значение имени скрипта<br />echo &quot;Вы запустили скрипт с именем $script_name и параметром $parametr1&quot; # команда echo выводит определенную строку, обращение к переменным осуществляется через $имя_переменной.<br />echo 'Вы запустили скрипт с именем $script_name и параметром $parametr1' # здесь мы видим другие кавычки, разница в том, что в одинарных кавычках не происходит подстановки переменных.<br />exit 0 #Выход с кодом 0 (удачное завершение работы скрипта)<br /></span><br /><br />Результат выполнения скрипта:<br /><br /><span style=" font-family:'Courier New';">ite@ite-desktop:~$ ./test.sh qwerty<br />Вы запустили скрипт с именем ./test.sh и параметром qwerty<br />Вы запустили скрипт с именем $script_name и параметром $parametr1<br /></span><br /><br />После того как мы познакомились как использовать переменные и передавать скрипту параметры, время познакомиться с зарезервированными переменными:<br /><br /><span style=" font-family:'Courier New';">$DIRSTACK - содержимое вершины стека каталогов<br />$EDITOR - текстовый редактор по умолчанию<br />$EUID - Эффективный UID. Если вы использовали программу su для выполнения команд от другого пользователя, то эта переменная содержит UID этого пользователя, в то время как...<br />$UID - ...содержит реальный идентификатор, который устанавливается только при логине.<br />$FUNCNAME - имя текущей функции в скрипте.<br />$GROUPS - массив групп к которым принадлежит текущий пользователь<br />$HOME - домашний каталог пользователя<br />$HOSTNAME - ваш hostname<br />$HOSTTYPE - архитектура машины.<br />$LC_CTYPE - внутренняя переменная, котороя определяет кодировку символов<br />$OLDPWD - прежний рабочий каталог<br />$OSTYPE - тип ОС<br />$PATH - путь поиска программ<br />$PPID - идентификатор родительского процесса<br />$SECONDS - время работы скрипта(в сек.)<br />$# - общее количество параметров переданных скрипту<br />$* - все аргументы переданыне скрипту(выводятся в строку)<br />$@ - тоже самое, что и предыдущий, но параметры выводятся в столбик<br />$! - PID последнего запущенного в фоне процесса<br />$$ - PID самого скрипта<br /><br /></span></p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:large; font-weight:600;">Условия</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';"><br />Условные операторы, думаю, знакомы практически каждому, кто хоть раз пытался на чем-то писать программы. В bash условия пишутся след. образом (как обычно на примере):<br />#!/bin/bash<br />source=$1 #в переменную source засовываем первый параметр скрипта<br />dest=$2 #в переменную dest засовываем второй параметр скрипта<br /><br />if [[ &quot;$source&quot; -eq &quot;$dest&quot; ]] # в ковычках указываем имена переменных для сравнения. -eq - логическое сравнение обозначающие &quot;равны&quot;<br />then # если они действительно равны, то<br />echo &quot;Применик $dest и источник $source один и тот же файл!&quot; #выводим сообщение об ошибке, т.к. $source и $dest у нас равны<br />exit 1 # выходим с ошибкой (1 - код ошибки)<br />else # если же они не равны<br />cp $source $dest # то выполняем команду cp: копируем источник в приемник<br />echo &quot;Удачное копирование!&quot;<br />fi #обозначаем окончание условия.<br /><br />Результат выполнения скрипта:<br />ite@ite-desktop:~$ ./primer2.sh 1 1<br />Применик 1 и источник 1 один и тот же файл!<br />ite@ite-desktop:~$ ./primer2.sh 1 2<br />Удачное копирование!<br /><br />Структура if-then-else используется следующим образом:<br />if &lt;команда или набор команд возвращающих код возврата(0 или 1)&gt;<br />then<br />&lt;если выражение после if истино, то выполняется этот блок&gt;<br />else<br />&lt;если выражение после if ложно, тот этот&gt;<br />В качестве команд возвращающих код возврата могут выступать структуры [[ , [ , test, (( )) или любая другая(или несколько) linux-команда.<br />test - используется для логического сравнения. после выражения, неоьбходима закрывающая скобка &quot;]&quot;<br />[ - синоним команды test<br />[[ - расширенная версия &quot;[&quot; (начиная с версии 2.02)(как в примере), внутри которой могут быть использованы || (или), &amp; (и). Долна иметь закрывающуб скобку &quot;]]&quot;<br />(( )) - математическое сравнение.<br />для построения многоярусных условий вида:<br />if ...<br />then ....<br />else<br />if ....<br />then....<br />else ....<br /><br />для краткости и читаемости кода, можно использовать структуру:<br />if ..<br />then ...<br />elif ...<br />then ...<br />elif ...<br /><br /></span></p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:large; font-weight:600;">Условия. Множественный выбор</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';"><br />Если необходимо сравнивать какоую-то одну переменную с большим количеством параметров, то целесообразней использовать оператор case.<br />#!/bin/bash<br />echo &quot;Выберите редатор для запуска:&quot;<br />echo &quot;1 Запуск программы nano&quot;<br />echo &quot;2 Запуск программы vi&quot;<br />echo &quot;3 Запуск программы emacs&quot;<br />echo &quot;4 Выход&quot;<br />read doing #здесь мы читаем в переменную $doing со стандартного ввода<br /><br />case $doing in<br />1)<br />/usr/bin/nano # если $doing содержит 1, то запустить nano<br />;;<br />2)<br />/usr/bin/vi # если $doing содержит 2, то запустить vi<br />;;<br />3)<br />/usr/bin/emacs # если $doing содержит 3, то запустить emacs<br />;;<br />4)<br />exit 0<br />;;<br />*) #если введено с клавиатуры то, что в case не описывается, выполнять следующее:<br />echo &quot;Введено неправильное действие&quot;<br /><br />esac #окончание оператора case.<br /><br />Результат работы:<br />ite@ite-desktop:~$ ./menu2.sh<br />Выберите редатор для запуска:<br />1 Запуск программы nano<br />2 Запуск программы vi<br />3 Запуск программы emacs<br />4 Выход<br /><br />После выбор цифры и нажатия Enter запуститься тот редактор, который вы выбрали(если конечно все пути указаны правильно, и у вас установлены эти редакторы :) )<br />Прведу список логических операторв, которые используются для конструкции if-then-else-fi:<br />-z # строка пуста<br />-n # строка не пуста<br />=, (==) # строки равны<br />!= # строки неравны<br />-eq # равно<br />-ne # неравно<br />-lt,(&lt; ) # меньше<br />-le,(&lt;=) # меньше или равно<br />-gt,(&gt;) #больше<br />-ge,(&gt;=) #больше или равно<br />! #отрицание логического выражения<br />-a,(&amp;&amp;) #логическое «И»<br />-o,(||) # логическое «ИЛИ»<br /><br />С основами языка и условиями мы разобрались, чтобы не перегружать статью, разобью её на несколько частей(допустим на 3). Во второй части разберем операторы цикла и выполнение математических операций.<br /><br /></span><span style=" font-family:'Courier New'; font-weight:600;">UPD:</span><span style=" font-family:'Courier New';"> Исправил некоторые ошибки<br /></span><span style=" font-family:'Courier New'; font-weight:600;">UPD:</span><span style=" font-family:'Courier New';"> Обновил часть про условия if-then-else<br /><br />Статьи на </span><a href="http://unix-admin.su"><span style=" font-family:'Courier New'; text-decoration: underline; color:#0000ff;">unix-admin.su</span></a> </p>
<p style=" margin-top:8px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Теги: </p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:12px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a href="https://habr.com/ru/search/?q=%5Blinux%20bash%20scripts%5D&amp;target_type=posts"><span style=" text-decoration: underline; color:#0000ff;">linux bash scripts</span></a> </li></ul>
<p style=" margin-top:8px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Хабы: </p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:12px; margin-left:30px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a href="https://habr.com/ru/hub/linux/"><span style=" text-decoration: underline; color:#0000ff;">Настройка Linux</span></a><span style=" color:#000000;"> </span></li></ul></body></html>